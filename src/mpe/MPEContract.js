import MPEAbi from 'singularitynet-platform-contracts/abi/MultiPartyEscrow';
import MPENetworks from 'singularitynet-platform-contracts/networks/MultiPartyEscrow';
import Web3 from 'web3';
import PaymentChannel from './PaymentChannel';
import { toBNString } from '../utils/bignumberHelper';
import { logMessage } from '../utils/logger';
import {BigNumber} from "bignumber.js";

class MPEContract {
    /**
     * @param {Web3} web3 - Web3 instance
     * @param {number} networkId - Network ID
     * @param {string} rpcEndpoint - RPC endpoint URL
     * @param {string} tokenName - Token name (FET/AGIX)
     * @param {string} standType - Stand type
     */
    constructor(web3, networkId, rpcEndpoint, tokenName, standType) {
        this._web3 = web3;
        this._networkId = networkId;
        this.rpcEndpoint = rpcEndpoint;
        this._tokenName = tokenName;
        this._standType = standType;
        this._contract = new this._web3.eth.Contract(
            MPEAbi,
            MPENetworks[networkId][tokenName][standType].address
        );
    }

    /**
     * An instance of Multi Party Contract generated by Web3
     * @type {Contract}
     * @see {@link https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html|Web3 Contract}
     */
    get contract() {
        return this._contract;
    }

    /**
     * The public address of the MPE account
     * @type {string}
     */
    get address() {
        return this._contract.options.address;
    }

    /**
     * Returns the balance against the address in Multi Party Escrow Account
     * @param {string} address - The public address of account
     * @returns {Promise<BigNumber>}
     */
    async balance(address) {
        // logger.debug('Fetching MPE account balance', { tags: ['MPE'] });
        return this.contract.methods.balances(address).call();
    }

    /**
     * Transfers tokens from the account to MPE account
     * @param {Account} account - The account from which the tokens needs to be transferred.
     * @param {BigNumber} amountInCogs - The amount to transfer in cogs
     * @returns {Promise.<TransactionReceipt>}
     */
    async deposit(account, amountInCogs) {
        const amount = toBNString(amountInCogs);
        // logger.info(`Depositing ${amount}cogs to MPE account`, {
        //     tags: ['MPE'],
        // });
        const depositOperation = this.contract.methods.deposit;
        return account.sendTransaction(this.address, depositOperation, amount);
    }

    /**
     * Withdraws tokens from MPE account and deposits to the account
     * @param {Account} account - The account to deposit tokens
     * @param {BigNumber} amountInCogs - The amount to be withdrawn
     * @returns {Promise.<TransactionReceipt>}
     */
    async withdraw(account, amountInCogs) {
        const amount = toBNString(amountInCogs);
        // logger.info(`Withdrawing ${amount}cogs from MPE account`, {
        //     tags: ['MPE'],
        // });
        const withdrawOperation = this.contract.methods.withdraw;
        return account.sendTransaction(this.address, withdrawOperation, amount);
    }

    /**
     * Opens a payment channel between an account and the given service with the specified tokens and expiry period
     * @param {Account} account - The account to create payment channel for
     * @param {ServiceClient} service - The AI service between which the payment channel needs to be opened
     * @param {BigNumber} amountInCogs - The initial tokens with the which payment channel needs to be opened
     * @param {BigNumber} expiry - The expiry of the payment channel in terms of block number
     * @returns {Promise.<TransactionReceipt>}
     */
    async openChannel(account, group, amountInCogs, expiry) {
        const amount = toBNString(amountInCogs);
        const expiryStr = toBNString(expiry);
        const {
            payment_address: recipientAddress,
            group_id_in_bytes: groupId,
        } = group;

        logMessage('info', 'MPEContract', `Opening new payment channel [amount: ${amount}, expiry: ${expiryStr}]`);
        const openChannelOperation = this.contract.methods.openChannel;
        try {
            const signerAddress = await account.getAddress();
            const openChannelFnArgs = [
                signerAddress,
                recipientAddress,
                groupId,
                amount,
                expiryStr,
            ];
            return account.sendTransaction(
                this.address,
                openChannelOperation,
                ...openChannelFnArgs
            );
        } catch (error) {
            throw new Error('opening neq payment channel error: ', error);
        }
    }

    /**
     * Deposits the specified tokens to MPE Account and opens a payment channel between an account and the given service
     * with the specified tokens and expiry period
     * @param {Account} account - The account against which the operations needs to be performed
     * @param {ServiceClient} service - The AI service between which the payment channel needs to be opened
     * @param {BigNumber} amountInCogs - The initial tokens with the which payment channel needs to be opened
     * @param {BigNumber} expiry - The expiry of the payment channel in terms of block number
     * @returns {Promise.<TransactionReceipt>}
     */
    async depositAndOpenChannel(account, group, amountInCogs, expiry) {
        const amount = toBNString(amountInCogs);
        const expiryStr = toBNString(expiry);
        const {
            payment_address: recipientAddress,
            group_id_in_bytes: groupId,
        } = group;
        try {
            const alreadyApprovedAmount = await account.allowance();
            if (amountInCogs > alreadyApprovedAmount) {
                await account.approveTransfer(amountInCogs);
            }

            const depositAndOpenChannelOperation =
                this.contract.methods.depositAndOpenChannel;
            const signerAddress = await account.getAddress();
            const operationArgs = [
                signerAddress,
                recipientAddress,
                groupId,
                amount,
                expiryStr,
            ];
            // logger.info(
            //     `Depositing ${amount}cogs to MPE address and Opening new payment channel [expiry: ${expiryStr}]`,
            //     { tags: ['MPE'] }
            // );
            return account.sendTransaction(
                this.address,
                depositAndOpenChannelOperation,
                ...operationArgs
            );
        } catch (error) {
            throw new Error(
                'depositing and opening new payment channel error: ',
                error
            );
        }
    }

    /**
     * Funds an existing payment channel
     * @param {Account} account - The account against which the operations needs to be performed
     * @param {BigNumber} channelId - The payment channel id
     * @param {BigNumber} amountInCogs - The number of tokens to fund the channel
     * @returns {Promise.<TransactionReceipt>}
     */
    async channelAddFunds(account, channelId, amountInCogs) {
        const channelIdStr = toBNString(channelId);
        const amount = toBNString(amountInCogs);
        try {
            await this._fundEscrowAccount(account, amountInCogs);

            // logger.info(
            //     `Funding PaymentChannel[id: ${channelIdStr}] with ${amount}cogs`,
            //     { tags: ['MPE'] }
            // );
            const channelAddFundsOperation =
                this.contract.methods.channelAddFunds;
            return account.sendTransaction(
                this.address,
                channelAddFundsOperation,
                channelIdStr,
                amount
            );
        } catch (error) {
            throw new Error('adding funds error: ', error);
        }
    }

    /**
     * Extends an existing payment channel
     * @param {Account} account - The account against which the operations needs to be performed
     * @param {BigNumber} channelId - The payment channel id
     * @param {BigNumber} expiry - The expiry in terms of block number to extend the channel
     * @returns {Promise.<TransactionReceipt>}
     */
    async channelExtend(account, channelId, expiry) {
        const channelIdStr = toBNString(channelId);
        const expiryStr = toBNString(expiry);
        // logger.info(
        //     `Extending PaymentChannel[id: ${channelIdStr}]. New expiry is block# ${expiryStr}`,
        //     { tags: ['MPE'] }
        // );
        const channelExtendOperation = this.contract.methods.channelExtend;
        return account.sendTransaction(
            this.address,
            channelExtendOperation,
            channelIdStr,
            expiryStr
        );
    }

    /**
     * Extends and adds funds to an existing payment channel
     * @param {Account} account - The account against which the operations needs to be performed
     * @param {BigNumber} channelId - The payment channel id
     * @param {BigNumber} expiry - The expiry in terms of block number to extend the channel
     * @param {BigNumber} amountInCogs - The number of tokens to fund the channel
     * @returns {Promise.<TransactionReceipt>}
     */
    async channelExtendAndAddFunds(account, channelId, expiry, amountInCogs) {
        const channelIdStr = toBNString(channelId);
        const amount = toBNString(amountInCogs);
        const expiryStr = toBNString(expiry);
        try {
            await this._fundEscrowAccount(account, amountInCogs);

            // logger.info(
            //     `Extending and Funding PaymentChannel[id: ${channelIdStr}] with amount: ${amount} and expiry: ${expiryStr}`,
            //     { tags: ['MPE'] }
            // );
            const channelExtendAndAddFundsOperation =
                this.contract.methods.channelExtendAndAddFunds;
            return account.sendTransaction(
                this.address,
                channelExtendAndAddFundsOperation,
                channelIdStr,
                expiryStr,
                amount
            );
        } catch (error) {
            throw new Error(
                'extending and funding payment channel error: ',
                error
            );
        }
    }

    /**
     * Claims unused tokens in a channel.
     * @param {Account} account - The account against which the operations needs to be performed
     * @param {BigNumber} channelId - Channel ID from which to claim the unused tokens
     * @returns {Promise.<TransactionReceipt>}
     */
    async channelClaimTimeout(account, channelId) {
        const channelIdStr = toBNString(channelId);
        // logger.info(
        //     `Claiming unused funds from expired channel PaymentChannel[id: ${channelIdStr}]`,
        //     { tags: ['MPE'] }
        // );
        const channelClaimTimeoutOperation =
            this.contract.methods.channelClaimTimeout;
        return account.sendTransaction(
            this.address,
            channelClaimTimeoutOperation,
            channelIdStr
        );
    }

    /**
     * Fetches the latest state of the payment channel
     * @param {BigNumber} channelId - The payment channel id
     * @returns {Promise<any>} - The return value(s) of the smart contract method. If it returns a single value, it’s returned as is. If it has multiple return values they are returned as an object with properties and indices:
     */
    async channels(channelId) {
        const channelIdStr = toBNString(channelId);
        // logger.debug(`Fetch latest PaymentChannel[id: ${channelIdStr}] state`, {
        //     tags: ['MPE'],
        // });
        return this.contract.methods.channels(channelIdStr).call();
    }

    /**
     * Fetches all the payment channels opened between the account and the service starting from the given block number
     * @param {Account} account
     * @param {ServiceClient} service
     * @param {number} [startingBlockNumber=MPE Contract deployment block number] - The starting block number to fetch the
     * open channels from
     * @returns {Promise.<PaymentChannel[]>}
     */
    async getPastOpenChannels(
        account,
        serviceMetadata,
        group
    ) {
        try {
            const fromBlock = await this._deploymentBlockNumber();
            let contract = this._contract;
            if (this.rpcEndpoint) {
                const _web3 = new Web3(this.rpcEndpoint);
                contract = new _web3.eth.Contract(
                    MPEAbi,
                    MPENetworks[this._networkId][this._tokenName][this._standType].address
                );
            }
            logMessage('debug', 'MPEContract', `Fetching all payment channel open events starting at block: ${fromBlock}`);

            const address = await account.getAddress();
            const decodedData = Buffer.from(group.group_id, 'base64').toString(
                'hex'
            );
            const groupId = `0x${decodedData}`;
            const options = {
                filter: {
                    sender: address,
                    recipient: group.payment_address,
                    groupId,
                },
                fromBlock,
                toBlock: 'latest',
            };
            const channelsOpened = await contract.getPastEvents(
                'ChannelOpen',
                options
            );
            return channelsOpened.map((channelOpenEvent) => {
                const { channelId } = channelOpenEvent.returnValues;
                return new PaymentChannel(
                    channelId,
                    this._web3,
                    account,
                    serviceMetadata,
                    this
                );
            });
        } catch (error) {
            throw new Error(
                'getting past open payment channels error: ',
                error
            );
        }
    }

    async _fundEscrowAccount(account, amountInCogs) {
        try {
            const address = await account.getAddress();
            let currentEscrowBalance = await this.balance(address);
            currentEscrowBalance = new BigNumber(currentEscrowBalance);
            const amountInCogsBN = new BigNumber(amountInCogs);
            if (amountInCogsBN.isGreaterThan(currentEscrowBalance)) {
                await account.depositToEscrowAccount(amountInCogsBN.minus(currentEscrowBalance));
            }
        } catch (error) {
            throw new Error('funding escrow account error: ', error);
        }
    }

    async _deploymentBlockNumber() {
        try {
            const { transactionHash } = MPENetworks[this._networkId][this._tokenName][this._standType];
            const { blockNumber } = await this._web3.eth.getTransactionReceipt(
                transactionHash
            );
            return blockNumber;
        } catch (error) {
            throw new Error('deployment block number error: ', error);
        }
    }
}

export default MPEContract;
